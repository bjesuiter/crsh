* TODO Pipe to file
* TODO stderr pipes
* TODO File redirection (input)
* TODO Persist history
* TODO Improve readme
* TODO Better error handling (don't crash ever)

* Everything above this line is for feature parity with existing shells

* TODO Think about how to do js shell logic outside of inline functions
How to interpolate env vars? Should it just be $HOME or should I do the more js-y ${HOME}?

The above is a good idea because you could also do e.g.:
touch file${new Date()}.js

touch $HOME/file.js

Here's how I think I can solve this, and also solve "source a file". Define a JS/unix hybrid. Something like this:
"Any statement that doesn't end in a semi colon should be executed as a unix command.
Any other statement should be eval'd in Deno."

And if I start a new scope, a newline should not yet execute the command, and should write some fancy bit to the prompt instead

And other fun stuff
* TODO Source a file
* TODO Fuzzyfinder
* TODO Make the indent area a beautiful auto-generated pattern
* TODO Autocompletion
* TODO Surface JS syntax errors while writing
* TODO Shortcut to re-run current JS snippet with previous output and show result
* TODO Pipe into functions (like fetchBody)
* TODO Async reader triggering of custom functions
This would be extra good combined with reading files as input
* TODO Improve builtin, function definitions
* TODO Let the user write functions that span multiple lines
* TODO Auto completion
** Also make it programmable! i.e. complete git branches etc. Maybe have auto complete let you supply a regex
_example_
if (/git checkout -b/.test()) {
    // perform git branch command
    // auto complete git branch
}

* TODO Add tests
* TODO Use typescript
* TODO Refactor to pull out reuseable parts
** Cursor movement and other termy, curses type stuff
** Make them available as hosted deno modules (on git?)
Like can you just have them on git and reference them in deno?


* Learnings

** VT100 codes
** Non-canonical input
** Piping stdin + stdout