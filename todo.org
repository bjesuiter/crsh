* TODO Fix issues at edges (when cursor is next to a newline character)
* TODO Refactor tty.js. Look at "moveCursorUp" and apply that approach elsewhere too
* TODO Fancier globs
e.g.

~/Documents/projects/deno_shell $ ls **/*.test.*
tests/util/evalAndInterpolateJS.test.js   tests/util/mergeArgsBetweenQuotes.test.js tests/util/replaceEnvVars.test.js

* TODO Source a file
Define a JS/unix hybrid. Something like this:
"Any statement that doesn't end in a semi colon should be executed as a unix command.
Any other statement should be eval'd in Deno."

* TODO Custom transformers
Determine what transformers to execute by reading the previous output

* TODO Friendly helpful errors
1. Something for transformers: "Looks like you are trying to use the json parser, but the previous output doesn't look like valid json."
1. Something for JS errors. Print it nicely to stderr with colors.
1. Other/missing commands. Maybe "did you mean" type message?

* TODO Simplify installation and execution (make work on webstorm etc too)
* TODO Rethink basic JS commands (ending with ;)
* TODO Persist history
* TODO Fuzzyfinder
* TODO Surface JS syntax errors while writing
* TODO Shortcut to re-run current JS snippet with previous output and show result
* TODO Async reader triggering of custom functions
This would be extra good combined with reading files as input
* TODO Improve builtin, function definitions
* TODO Let the user write functions that span multiple lines

* TODO Manage resources/resource IDs.

Do this in a more Deno way than bash way. Think of resources over file descriptors.

** Maybe a more readable way too.

Always left to right?

Cases: stdout, in, err, files

* TODO Background jobs

* TODO Fix random extra line in ({ lines })
* TODO Refactor cursor movement in tty.js
* TODO Refactor the main file. Process execution is messy
There are different cases (JS execution, process execution) that overlap a little here and there.
Think about how it could be tidier
* TODO Add tests
* TODO Use typescript
* TODO Refactor to pull out reuseable parts
** Cursor movement and other termy, curses type stuff
** Make them available as hosted deno modules (on git?)
Like can you just have them on git and reference them in deno?
* TODO Add error log. Catch when there's an autocomplete exception (and other exceptions) and log them to a file.
This is how I should tie into fixing all crashes. Should be graceful


* Learnings

** VT100 codes
** Non-canonical input
** Piping stdin + stdout
** File descriptors. Abstractions make this a little difficult. Can feed these difficulties back into the Deno project?
** OS Signals

** resources
https://catonmat.net/bash-one-liners-explained-part-three#:~:text=When%20bash%20starts%20it%20opens,them%20and%20read%20from%20them.